package fr.baretto.ollamassist.ai.store;import com.intellij.openapi.application.ApplicationManager;import com.intellij.openapi.vfs.VirtualFile;import com.intellij.openapi.vfs.VirtualFileEvent;import com.intellij.openapi.vfs.VirtualFileListener;import dev.langchain4j.data.document.loader.FileSystemDocumentLoader;import dev.langchain4j.data.segment.TextSegment;import dev.langchain4j.store.embedding.EmbeddingStoreIngestor;import fr.baretto.ollamassist.chat.Context;import fr.baretto.ollamassist.events.StoreNotifier;import lombok.extern.slf4j.Slf4j;import org.jetbrains.annotations.NotNull;import java.util.Collections;import java.util.List;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;@Slf4jpublic class StoreFileListener implements VirtualFileListener {    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);    private final LuceneEmbeddingStore<TextSegment> store;    private final Set<String> currentModifiedFiles = Collections.newSetFromMap(new ConcurrentHashMap<>());    public StoreFileListener(LuceneEmbeddingStore<TextSegment> store) {        this.store = store;        ApplicationManager.getApplication().getMessageBus()                .connect()                .subscribe(StoreNotifier.TOPIC, (StoreNotifier) this::cleanStore);    }    private void cleanStore() {        store.removeAll();    }    @Override    public void fileCreated(@NotNull VirtualFileEvent event) {        scheduler.schedule(() -> {            VirtualFile file = event.getFile();            if (file.getLength() > 0) {                try {                    EmbeddingStoreIngestor.ingest(List.of(FileSystemDocumentLoader.loadDocument(event.getFile().getPath())), store);                } catch (Exception exception) {                    log.error("Exception during ingestion of new file : " + exception.getMessage());                }            }        }, 2, TimeUnit.SECONDS);    }    @Override    public void contentsChanged(@NotNull VirtualFileEvent event) {        if (!currentModifiedFiles.contains(event.getFileName())) {            currentModifiedFiles.add(event.getFileName());            store.removeAll(new IdEqualsFilter(event.getFileName()));//entry -> isSameFile(entry, event));            VirtualFile file = event.getFile();            scheduler.schedule(() -> {                if (file.getLength() > 0) {                    try {                        EmbeddingStoreIngestor.ingest(List.of(FileSystemDocumentLoader.loadDocument(event.getFile().getPath())), store);                        currentModifiedFiles.remove(event.getFileName());                    } catch (Exception exception) {                        log.error("Exception during ingestion of new file : " + exception.getMessage());                    }                }            }, 2, TimeUnit.SECONDS);        }    }    @Override    public void fileDeleted(@NotNull VirtualFileEvent event) {        store.removeAll(new IdEqualsFilter(event.getFileName()));    }    public void load(Context context) {        IndexRegistry projectRegistry = new IndexRegistry();        if (!projectRegistry.isIndexed(context.project().getName())) {            new InitEmbeddingStoreTask(context.project(), store).queue();        }    }    public void forceLoad(Context context) {        store.removeAll();        new IndexRegistry().removeProject(context.project().getName());        new InitEmbeddingStoreTask(context.project(), store).queue();    }}